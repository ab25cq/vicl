
class CLNodeType
{
    typeName:String;
    genericsTypes:CLNodeType[];
    numGenericsTypes: int;

    def initialize(type_name:String) {
        typeName = type_name;
        genericsTypes = new CLNodeType[CLParser.GENERICS_TYPES_MAX]();
        numGenericsTypes = 0;
    }

    def toString(): String {
        result := "";
        result.append(typeName);

        if(numGenericsTypes > 0) {
            result.append("<");

            for(i := 0; i<numGenericsTypes; i++) {
                result.append(genericsTypes[i].toString());
                if(i != numGenericsTypes-1) {
                    result.append(",");
                }
            }

            result.append(">");
        }

        result;
    }

    def show() {
        println("Type is \{toString()}");
    }
}

interface CLNodeTree
{
    def kind():int;
    def kind(value:int);

    def left(value:CLNodeTree);
    def left():CLNodeTree;

    def right(value:CLNodeTree);
    def right():CLNodeTree;

    def middle(value:CLNodeTree);
    def middle():CLNodeTree;

    def sourceName():String;
    def sourceName(sname:String);

    def sourceLine():int;
    def sourceLine(line:int);

    def type():CLNodeType;
    def type(type: CLNodeType);

    def show();

    enum {
        IntType, PlusExp
    }
}

class CLNodeTreeBase
{
    kind:int;
    left:CLNodeTree;
    right:CLNodeTree;
    middle:CLNodeTree;

    sourceName:String;
    sourceLine:int;

    type:CLNodeType;
}

class CLNodeTreeInt
{
    base:delegate CLNodeTreeBase;
    value:int;

    def initialize(value:int, sname:String, sline:int) {
        base = CLNodeTreeBase();

        kind(CLNodeTree.IntType);

        sourceName(sname);
        sourceLine(sline);

        base.type(new CLNodeType("int"));

        value = value;
    }

    def show() {
        println("int value \{value}");
    }
}

class CLNodeTreePlus
{
    base:delegate CLNodeTreeBase;

    def initialize(left:CLNodeTree, right:CLNodeTree, sname:String, sline:int) {
        base = CLNodeTreeBase();

        kind(CLNodeTree.PlusExp);

        self.left(left);
        self.right(right);

        self.base.type(self.left().type());

        sourceName(sname);
        sourceLine(sline);
    }

    def show() {
        println("plus tree");
        println("<-- left -->");
        if(!left().identifyWith(null)) {
            left().show();
        }
        else {
            println("null");
        }

        println("<-- right -->");
        if(!right().identifyWith(null)) {
            right().show();
        }
        else {
            println("null");
        }
    }
}

class CLParser
{
    sourceBuffer:Buffer;
    p:Buffer;
    type:CLNodeType;

    GENERICS_TYPES_MAX:static int;
    PARAMS_MAX:static int;

    sourceName:String;
    sourceLine:int;

    def initialize(): native static;

    def initialize(sname:String) {
        sourceName = sname;
        
        sourceBuffer = File.read(sourceName);
        sourceBuffer.append(0y);
    }
    
    def initialize(buffer:String, sname:String) {
        sourceName = sname;
        
        sourceBuffer = buffer.toBuffer();
        sourceBuffer.append(0y);
    }

    def skipSpacesAndLF() {
        while(p->byte == ' ' || p->byte == '\t' || p->byte == '\n') {
            p++;
        }
    }

    def expressionNode():CLNodeTree? {
        result:CLNodeTree? = null;

        if(p->byte >= '0' && p->byte <= '9') {
            value:int = 0;
            while(p->byte >= '0' && p->byte <= '9') {
                value = value * 10 + p->byte - '0';
                p++;
            }
            skipSpacesAndLF();

            result = CLNodeTreeInt(value, sourceName, sourceLine);
        }

        return result;
    }

    def plusAndMinus(): CLNodeTree? throws Exception {
        result:CLNodeTree? = expressionNode();

        while(true) {
            if(p->byte == '+') {
                p++;
                skipSpacesAndLF();

                right := expressionNode();

                if(right.identifyWith(null)) {
                    throw new Exception("\{sourceName} \{sourceLine}: Right expression is null.");
                }

                result = CLNodeTreePlus(result, right, sourceName, sourceLine);
            }
            else {
                break;
            }
        }

        return result;
    }

    def expression(): CLNodeTree? throws Exception {
        result :CLNodeTree? = plusAndMinus();

        return result;
    }

    def parse() {
        p = sourceBuffer;
        sourceLine = 1;

        while(p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(!exp.identifyWith(null)) {
                exp.show();
                exp.type().show();
            }
        }
    }

    def getType(): String {
        p = sourceBuffer;
        sourceLine = 1;

        type := "";

        while(p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(!exp.identifyWith(null)) {
                type = exp.type().typeName;
            }
        }

        return type;
    }

    def getTypeWithBoxing(): String {
        return Clover.primitiveClassToBoxingClass(getType());
    }
}
