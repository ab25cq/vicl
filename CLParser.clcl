
class CLNodeType
{
    typeName:String;
    genericsTypes:CLNodeType[];
    numGenericsTypes: int;

    def initialize(type_name:String) {
        typeName = type_name;
        genericsTypes = new CLNodeType[CLParser.GENERICS_TYPES_MAX]();
        numGenericsTypes = 0;
    }

    def toString(): String {
        result := "";
        result.append(typeName);

        if(numGenericsTypes > 0) {
            result.append("<");

            for(i := 0; i<numGenericsTypes; i++) {
                result.append(genericsTypes[i].toString());
                if(i != numGenericsTypes-1) {
                    result.append(",");
                }
            }

            result.append(">");
        }

        result;
    }

    def show() {
        println("Type is \{toString()}");
    }
}

interface CLNodeTree
{
    def kind():int;
    def kind(value:int);

    def left(value:CLNodeTree);
    def left():CLNodeTree;

    def right(value:CLNodeTree);
    def right():CLNodeTree;

    def middle(value:CLNodeTree);
    def middle():CLNodeTree;

    def sourceName():String;
    def sourceName(sname:String);

    def sourceLine():int;
    def sourceLine(line:int);

    def type():CLNodeType;
    def type(type: CLNodeType);

    def show();

    def equals(right:Self): bool;
    def toString(): String;
    def clone(): Self;

    enum {
        IntType, PlusExp, StringType
    }
}

module CLNodeTreeBase
{
    kind:int;
    left:CLNodeTree?;
    right:CLNodeTree?;
    middle:CLNodeTree?;

    sourceName:String;
    sourceLine:int;

    type:CLNodeType;

    def show() {
        self.toString().println();
    }
}

class CLNodeTreeInt
{
    include CLNodeTreeBase;

    value:int;

    def initialize(value:int, sname:String, sline:int) {
        self.kind = CLNodeTree.IntType;

        self.sourceName = sname;
        self.sourceLine = sline;

        self.type = CLNodeType("int");

        self.value = value;
    }

    def toString():String {
        "int value \{self.value}";
    }

    def equals(right:CLNodeTreeInt): bool {
        self.type == right.type && self.value == right.value;
    }
}

class CLNodeTreeString
{
    include CLNodeTreeBase;

    value:String;

    def initialize(value:String, sname:String, sline:int) {
        self.kind = CLNodeTree.StringType;

        self.sourceName = sname;
        self.sourceLine = sline;

        self.type = CLNodeType("String");

        self.value = value;
    }

    def toString():String {
        "String value \{self.value}";
    }

    def equals(right:CLNodeTreeString): bool {
        self.type == right.type && self.value.equals(right.value);
    }
}

class CLNodeTreePlus
{
    include CLNodeTreeBase;

    def initialize(left:CLNodeTree?, right:CLNodeTree?, sname:String, sline:int) {
        self.kind = CLNodeTree.PlusExp;

        self.sourceName = sname;
        self.sourceLine = sline;

        self.left = left;
        self.right = right;

        self.type = self.left.type();
    }

    def toString():String {
        "plus tree left \{self.left?.toString()} right \{self.right?.toString}";
    }

    def equals(right:CLNodeTreePlus): bool {
        self.type == right.type;
    }
}

class CLParser
{
    sourceBuffer:Buffer;
    p:Buffer;
    type:CLNodeType;

    GENERICS_TYPES_MAX:static int;
    PARAMS_MAX:static int;

    sourceName:String;
    sourceLine:int;

    def initialize(): native static;

    def initialize(sname:String) {
        sourceName = sname;
        
        sourceBuffer = File.read(sourceName);
        sourceBuffer.append(0y);
    }
    
    def initialize(buffer:String, sname:String) {
        sourceName = sname;
        
        sourceBuffer = buffer.toBuffer();
        sourceBuffer.append(0y);
    }

    def skipSpacesAndLF() {
        while(p->byte == ' ' || p->byte == '\t' || p->byte == '\n') {
            p++;
        }
    }
    def parseStringExpression():Tuple2<CLNodeTree?,Bool> {
        result:CLNodeTree? = null;

        while(p->byte == ';') {
            result = expression();
        }

        if(p->byte == '}') {
            p++;
            skipSpacesAndLF();
            return (null, true.toBool());
        }

        return (result, false.toBool());
    }

    def expressionNode():CLNodeTree? {
        result:CLNodeTree? = null;

        if(p->byte >= '0' && p->byte <= '9') {
            value:int = 0;
            while(p->byte >= '0' && p->byte <= '9') {
                value = value * 10 + p->byte - '0';
                p++;
            }
            skipSpacesAndLF();

            result = CLNodeTreeInt(value, sourceName, sourceLine);
        }
        elif(p->byte == '"') {
            p++;

            var value := "";
            var string_expression := false;

            while(true) {
                if(p->byte == '"') {
                    p++;
                    skipSpacesAndLF();
                    break;
                }
                elif(p->byte == '\\') {
                    p++;

                    when (p->byte.to_char) {
                        case ('0') {
                            value.append('\0');
                            p++;
                        }

                        case ('{') {
                            p++;

                            end_flag := false;
                            (result,end_flag) = parseStringExpression();

                            end_flag.negative().if {
                                string_expression = true;
                            }
                        }

                        case ('n') {
                            value.append('\n');
                            p++;
                        }

                        case ('t') {
                            value.append('\t');
                            p++;
                        }

                        case ('r') {
                            value.append('\r');
                            p++;
                        }

                        case ('a') {
                            value.append('\a');
                            p++;
                        }

                        case ('\\') {
                            value.append('\\');
                            p++;
                        }

                        else {
                            value.append(p->byte.to_char);
                            p++;
                        }
                    }
                }
                elif(p->byte == '\0') {
                    throw Exception("close \" to make string value");
                }
                else {
                    if(p->byte == '\n') {
                        sourceLine++
                    }

                    value.append(p->byte.to_char);
                    p++;
                }
            }

            skipSpacesAndLF();

            string_expression.negative().if {
                result = CLNodeTreeString(value, sourceName, sourceLine);
            }
        }
        elif(p->byte == '(') {
            p++;
            skipSpacesAndLF();

            result = expression();

            if(result == null) {
                throw Exception("\{sourceName} \{sourceLine}: expression is null.");
            }

            if(p->byte == ')') {
                p++;
                skipSpacesAndLF();
            }
            else {
                throw Exception("\{sourceName} \{sourceLine}: require )");
            }
        }

        return result;
    }

    def plusAndMinus(): CLNodeTree? throws Exception {
        result:CLNodeTree? = expressionNode();

        while(true) {
            if(p->byte == '+') {
                p++;
                skipSpacesAndLF();

                right := expressionNode();

                if(right == null) {
                    throw Exception("\{sourceName} \{sourceLine}: Right expression is null.");
                }

                result = CLNodeTreePlus(result, right, sourceName, sourceLine);
            }
            else {
                break;
            }
        }

        return result;
    }

    def expression(): CLNodeTree? throws Exception {
        result :CLNodeTree? = plusAndMinus();

        return result;
    }

    def parse() {
        p = sourceBuffer;
        sourceLine = 1;

        while(p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(exp != null) {
                exp.show();
                exp.type().show();
            }
        }
    }

    def getType(): String {
        p = sourceBuffer;
        sourceLine = 1;

        type := "";

        while(p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(exp != null) {
                type = exp.type().typeName;
            }
        }

        return type;
    }

    def getTypeWithBoxing(): String {
        return Clover.primitiveClassToBoxingClass(getType());
    }
}
