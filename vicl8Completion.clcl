include "vicl7Undo.clcl"

class ViClone
{
    def initialize() {
        inherit();
    }

    def getMethodDefinitionTop(): Tuple2<Integer, Integer> {
        for(i:=getRealPosY()-1; i>=0; i--) {
            line := texts.items(i);

            if(line.match(/def\s+.+\(/)) {
                for(y := i; y<texts.length(); y++) {
                    line := texts.items(y);

                    x := line.indexOf("{");

                    if(x != -1) {
                        return (y, x);
                    }
                }
            }
        }

        return (-1, -1)
    }
    def getNextmethodDefinitionTop(): Tuple2<Integer, Integer> {
        for(i:=getRealPosY()+1; i<texts.length(); i++) {
            line := texts.items(i);

            if(line.match(/def\s+.+\(/)) {
                for(y := i; y<texts.length(); y++) {
                    line := texts.items(y);

                    x := line.indexOf("{");

                    if(x != -1) {
                        return (y, x);
                    }
                }
            }
        }

        return (-1, -1)
    }
    
    
    def defaultKeyEvents() {
        inherit();

        keyEvents['['.to_int] = lambda(self:ViClone, key:int, key2:int) {
            when(key2) {
                case ('['.to_int) {
                    (y, x) := getMethodDefinitionTop();

                    if(y != -1 && x != -1) {
                        moveCursor(y, x);
                    }
                }
            }
        }

        keyEvents[']'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            when(key2) {
                case (']'.to_int) {
                    (y, x) := getNextmethodDefinitionTop();

                    if(y != -1 && x != -1) {
                        moveCursor(y, x);
                    }
                }
            }
        }
    }

    def methodNameCompletion(line:String) {
        source := "";
        if(fileName.match(/.+\.clcl/)) {
            (y, x) := getMethodDefinitionTop();
            
            source := "";
            
            line2 := texts.items(y);
            source.append(line2.subString(x+1, -1));
            source.append("\n");
            
            for(i:=y; i<getRealPosY(); i++) {
                line2 = texts.items(i);
                source.append(line2);
                source.append("\n");
            }
            
            line2 = texts.items(getRealPosY());
            line2 = line2.scan(/\s*(.+)\..*$/).items(1);
            source.append(line2);
        }
        else {
            for(i:=0; i<getRealPosY(); i++) {
                line2 := texts.items(i);
                source.append(line2);
                source.append("\n");
            }
            line2 := texts.items(i);
            line2 = line2.scan(/^(.+)\..*$/).items(1);
            source.append(line2);
        }
        
        type_name := source.toCommand().tyclover2().toString();

        type_name2 := type_name.chomp();
        if(type_name2.match(/\s*(.+)\s*/)) {
            type_name2 = type_name2.scan(/\s*(.+)\s*/).items(0);
        }
        
        boxing_type_name := Clover.primitiveClassToBoxingClass(type_name2);
        
        class_name := boxing_type_name;
        if(boxing_type_name.match(/.+<.+>/)) {
            class_name = boxing_type_name.scan(/(.+)<.+>/).items(1);
        }

        if(class_name.equals("")) {
            messageBox("require type for Method name completion");
            return; 
        }

        klass:Class? = null;
        try {
            klass = Class(class_name);
        } catch(e:Exception) {
            messageBox("class not found \{class_name}");
            return;
        }

        methods := klass.getMethods();

        words := SortableList<String>();
        methods.each {
            words.add(it.methodNameAndParams);
        }

        ### getting inputing word ###
        start_i := getRealPosX()-1;
        if(start_i >= line.length()) {
            start_i = line.length()-1;
        }
        inputing_text := "";
        for(i:=start_i; i >= 0; i--) {
            if(line.chars(i).isalnum() || line.chars(i) == '_') 
            {
                inputing_text.insert(0, line.chars(i)); 
            }
            elif(line.chars(i) == '\.') {
                break;
            }
            else {
                break; 
            } 
        }
        if(i < 0) {
            i = 0;
        }
        else {
            i++;
        }

        candidates := words.map { 
            it.subString(0, MaxX-1) 
        }.select { 
            it.indexOf(inputing_text) == 0 && !it.equals(inputing_text)
        }.sort().uniq();

        if(candidates.length() == 0) {
        }
        elif(candidates.length() == 1) {
            selected_string := candidates.items(0).scan(/^(.+\()/).items(1);

            line.delete(i, getRealPosX()); 
            line.insert(i, selected_string);
            cursorX += selected_string.length() - (getRealPosX() - i)
        }
        else {
            index := selectStrings(line.subString(0, MaxX-1), candidates);

            if(index != -1) {
                selected_string := candidates.items(index).scan(/^(.+\()/).items(1);
                line.delete(i, getRealPosX());
                line.insert(i, selected_string);
                cursorX += selected_string.length() - (getRealPosX() - i)
            }
        }
    }
    
    def clover2Completion() {
        line := texts.items(getRealPosY());
        
        if(line.match(/(.+)\..*/)) {
            methodNameCompletion(line);
        }
    }
    
    def completion() {
        words := texts.join("\n").scan(/[a-zA-Z_]+/);
        line := texts.items(getRealPosY());
        
        ### getting inputing word ###
        start_i := getRealPosX()-1;
        if(start_i >= line.length()) {
            start_i = line.length()-1;
        }
        inputing_text := "";
        for(i:=getRealPosX()-1; i >= 0; i--) {
            if(line.chars(i).isalnum() || line.chars(i) == '_') 
            {
                inputing_text.insert(0, line.chars(i)); 
            } 
            else {
                break; 
            } 
        }
        if(i < 0) {
            i = 0;
        }
        else {
            i++;
        }

        candidates := words.map { 
            it.subString(0, MaxX-1) 
        }.select { 
            it.indexOf(inputing_text) == 0 && !it.equals(inputing_text)
        }.sort()
        .uniq();

        if(candidates.length() == 0) {
        }
        elif(candidates.length() == 1) {
            selected_string := candidates.items(0);

            line.delete(i, getRealPosX()); 
            line.insert(i, selected_string);
            cursorX += selected_string.length() - (getRealPosX() - i)
        }
        else {
            index := selectStrings(line.subString(0, MaxX-1), candidates);

            if(index != -1) {
                selected_string := candidates.items(index);
                line.delete(i, getRealPosX());
                line.insert(i, selected_string);
                cursorX += selected_string.length() - (getRealPosX() - i)
            }
        }
    } 
}