include "vicl3ReadFile.clcl"

class ViClone
{
    var cursorX:int;
    var cursorY:int;
    var scrollTopY:int;
    var scrollTopX:int;
    var visibleTexts:SortableList<String>?;
    var visibleTextsPos:EqualableList<Tuple3<Integer, Integer, Integer>>;

    var spaceString: String;

    var MaxX:int;
    var MaxY:int;
    
    def initialize() {
        inherit();
    }

    def makeMaxxy() {
        MaxX = getmaxx() - dirPaneLength;
        MaxY = getmaxy();
    }

    def makeVisibleTexts() {
        visibleTexts = SortableList<String>();
        visibleTextsPos = EqualableList<Tuple3<Integer, Integer, Integer>>();
        
        y := 0;
        for(i:=scrollTopY; y < MaxY-1; i++) {
            line := texts.items(i);
            if(line == null) {
                break;
            }

            if(line.length() > MaxX-1) {
                x := 0;
                while(x < line.length() && y < MaxY-1) {
                    visibleTexts.add(line.subString(x, x+MaxX-1));
                    visibleTextsPos.add((i, x, line.length() / (MaxX-1)+1));
                    
                    x += MaxX-1;
                    y++;
                }
            }
            else {
                visibleTexts.add(line);
                visibleTextsPos.add((i, 0, 1));
                y++;
            }
        }
    }

    def fixCursorAndScrollTop(scrolltop_y_before:int) {
        if(visibleTexts.length() < MaxY -1 && cursorY >= visibleTexts.length()) 
        {
            cursorY = visibleTexts.length()-1;
        }

        if(cursorY >= MaxY-1) {
            (tmp, tmp2, top_line_size) := visibleTextsPos.items(0);

            if(top_line_size >= MaxY-1)
            {
                scrollTopY++;
                cursorY = 0;
                cursorX = 0;
            }
            else {
                scroll_size := cursorY - MaxY +2;

                scrollTopY += scroll_size;
                cursorY -= scroll_size + top_line_size -1;
            }
        }
        if(cursorY < 0) {
            scroll_size := -cursorY;

            cursorY = 0;
            scrollTopY -= scroll_size;
        }
        
        if(scrollTopY >= texts.length()) {
            cursorY = 0;
            scrollTopY = texts.length()-1;
        }

        if(scrollTopY < 0) {
            scrollTopY = 0;
        }

        if(scrolltop_y_before != scrollTopY) {
            makeVisibleTexts();
        }

        line := visibleTexts.items(cursorY);

        if(line == null || line.length() == 0) {
            cursorX = 0;
        }

        if(cursorX < 0) {
            cursorX = 0;
        }
        
        if(cursorY >= visibleTexts.length()) {
            cursorY = visibleTexts.length() - 1;
        }
    }

    def defaultKeyEvents() {
        inherit();

        keyEvents['j'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            cursorY++;

            fixCursorAndScrollTop(scrollTopY);
        }
        keyEvents[KEY_DOWN] = keyEvents['j'.to_int];
        keyEvents['k'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            cursorY--;

            fixCursorAndScrollTop(scrollTopY);
        }
        keyEvents[KEY_UP] = keyEvents['k'.to_int];
        keyEvents['h'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            cursorX--;

            fixCursorAndScrollTop(scrollTopY);
        }
        keyEvents[KEY_LEFT] = keyEvents['h'.to_int];
        keyEvents['l'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            cursorX++;

            fixCursorAndScrollTop(scrollTopY);
        }
        keyEvents[KEY_RIGHT] = keyEvents['l'.to_int];
        keyEvents['0'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            var scrolltop_y_before = scrollTopY;
            cursorX = 0;
            fixCursorAndScrollTop(scrolltop_y_before);
        }
        keyEvents['$'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            var scrolltop_y_before = scrollTopY;
            line := visibleTexts.items(cursorY);
            cursorX = line.length()-1;
            fixCursorAndScrollTop(scrolltop_y_before);
        }
        keyEvents[('D'-'A').to_int+1] = lambda(self:ViClone, key:int, key2:int) {  # Control-D
            var scrolltop_y_before = scrollTopY;

            cursorY += MaxY / 2;

            fixCursorAndScrollTop(scrolltop_y_before);
        }
        keyEvents[('U'-'A').to_int+1] = lambda(self:ViClone, key:int, key2:int) {  # Control-U
            var scrolltop_y_before = scrollTopY;

            cursorY -= MaxY / 2;

            fixCursorAndScrollTop(scrolltop_y_before);
        }
        keyEvents['G'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            var scrolltop_y_before = scrollTopY;

            cursorY = 999999;

            fixCursorAndScrollTop(scrolltop_y_before);
        }
        keyEvents['g'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            if(key2 == 'g'.to_int) {
                var scrolltop_y_before = scrollTopY;

                cursorX = 0;
                cursorY = 0;
                scrollTopY = 0;

                fixCursorAndScrollTop(scrolltop_y_before);
            }
        }
        keyEvents[('L'-'A').to_int+1] = lambda(self:ViClone, key:int, key2:int) {  # Control-L
            makeVisibleTexts()
            clear();
            view();
        }
    }
    
    def makeSpaces() {
        var maxx = getmaxx();

        spaceString = " ".multiply(maxx);
    }

    def clearWithoutBlink() {
        var maxy = getmaxy();

        for(i:=0; i<maxy-1; i++) {
            mvprintw(i, 0, spaceString);
        }
    }

    def view() {
        clearWithoutBlink(); 
        
        dirView(); 

        for(y:=0; y<visibleTexts.length(); y++) {
            line := visibleTexts.items(y);

            if(line == null) {
                break;
            }

            ### cursor line ####
            if(cursorY == y) {
                if(line.length() == 0) {
                    attron(A_REVERSE);
                    mvprintw(y, 0 + dirPaneLength, " ");
                    attroff(A_REVERSE);
                }
                else {
                    if(cursorX >= line.length()) {
                        mvprintw(y, 0 + dirPaneLength, line);

                        attron(A_REVERSE);
                        mvprintw(y, line.length() + dirPaneLength, " ");
                        attroff(A_REVERSE);
                    }
                    else {
                        mvprintw(y, 0+dirPaneLength
                            , line.subString(0, cursorX));

                        c := line.chars(cursorX);

                        attron(A_REVERSE);
                        mvprintw(y, cursorX+dirPaneLength
                            , "%s", array { c.toString() });
                        attroff(A_REVERSE);

                        mvprintw(y, cursorX+1+dirPaneLength
                            , line.subString(cursorX+1, -1));
                    }
                }
            }
            ### visible line ###
            else {
                mvprintw(y, 0 + dirPaneLength, line);
            }
       }

       attron(A_REVERSE);
       try {
           mvprintw(MaxY-1, 0, "%s %d %d undo(%d:%d) size(%d,%d) cursor(%d,%d) scroll(%d,%d)", array { (self.fileName?.nothing():""), scrollTopY+cursorY, scrollTopX+cursorX, undoIndex, undoTexts.length(), MaxX, MaxY, cursorX, cursorY, scrollTopX, scrollTopY });
       }
       catch (e:Exception) {
       }
       attroff(A_REVERSE);
    }

    def runKeyEvents(key:int) {
        if(mode == EDITMODE) {
            if(keyEvents[key] != null) {
                var key2 := 0;
                when(key) {
                    case ('d'.to_int, 'c'.to_int, 'Z'.to_int, 'g'.to_int, 'z'.to_int) {
                        key2 = getch();
                    }
                }
                keyEvents[key](self, key, key2);
            }
        }
        else {
            inherit(key);
        }
    }
}