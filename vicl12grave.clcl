include "vicl11VisualMode.clcl"

class ViClone
{
    graveCursorPosition:int[];
    numGraveCursorPosition: int;
    savedCursorPosition: int;
     
    def initialize() {
        inherit();
        
        numGraveCursorPosition = 'z'-'a'+1;
        graveCursorPosition = int[numGraveCursorPosition]();
        for(i:=0; i<numGraveCursorPosition; i++) {
            graveCursorPosition[i] = -1;
        }
        savedCursorPosition = -1;
    }

    def defaultKeyEvents() {
        inherit();

        ### Insert Mode ###
        keyEvents['`'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            if(key2.to_char >= 'a' && key2.to_char <= 'z') {
                n := (key2 - 'a').to_int;
                if(graveCursorPosition[n] != -1) {
                    savedCursorPosition = getRealPosY();
                    moveCursor(graveCursorPosition[n], 0);
                }
            }
            elif(key2.to_char == '`') {
                if(savedCursorPosition != -1) {
                    saved_cursor_position := getRealPosY();
                    moveCursor(savedCursorPosition, 0);
                    savedCursorPosition = saved_cursor_position;
                }
            }
        }
        keyEvents['m'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            if(key2.to_char >= 'a' && key2.to_char <= 'z') {
                n := (key2 - 'a').to_int;
                graveCursorPosition[n] = getRealPosY();
            }
        }
    }

    def visualMode(key:int) {
        when(key) {
            case (('['-'A').to_int+1) {
                mode = EDITMODE;
                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('j'.to_int, KEY_DOWN) {
                cursorY++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('k'.to_int, KEY_UP) {
                cursorY--;

                fixCursorAndScrollTop(scrollTopY);
            }
            case (('D'-'A').to_int+1) {
                cursorY += (MaxY-1) / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            case (('U'-'A').to_int+1) {
                cursorY -= (MaxY-1) / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('l'.to_int, KEY_RIGHT) {
                cursorX++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('G'.to_int) {
                scrolltop_y_before := scrollTopY;
    
                cursorY = 999999;
    
                fixCursorAndScrollTop(scrolltop_y_before);
            }
            case ('g'.to_int) {
                key2 := getch();
                
                if(key2 == 'g'.to_int) {
                    var scrolltop_y_before = scrollTopY;
    
                    cursorX = 0;
                    cursorY = 0;
                    scrollTopY = 0;
    
                    fixCursorAndScrollTop(scrolltop_y_before);
                }
            }
            
            case ('h'.to_int, KEY_LEFT) {
                cursorX--;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('y'.to_int) {
                line := getRealPosY();

                if(visualModeStart < line) {
                    clipBoard = texts.subList(visualModeStart, line+1);
                }
                else {
                    clipBoard = texts.subList(line, visualModeStart+1);
                }

                mode = EDITMODE;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('d'.to_int) {
                addUndoText();

                real_pos_y := getRealPosY();

                if(visualModeStart < real_pos_y) {
                    clipBoard = texts.subList(visualModeStart, real_pos_y+1);
                    texts.deleteWithRange(visualModeStart, real_pos_y+1);
                    
                    if(texts.length() == 0) {
                        texts.add("");
                    }
                }
                else {
                    clipBoard = texts.subList(real_pos_y, visualModeStart+1);
                    texts.deleteWithRange(real_pos_y, visualModeStart+1);
                    if(texts.length() == 0) {
                        texts.add("");
                    }
                }

                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
                mode = EDITMODE;
                moveCursor(visualModeStart, 0);
            }
            case ('>'.to_int) {
                addUndoText();

                texts.subList(visualModeStart, getRealPosY()+1).each 
                {
                    it.insert(0, "    ");
                } 
                
                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
            }
            case ('<'.to_int) {
                addUndoText();

                y := visualModeStart; 
                y2 := getRealPosY();
                
                lines := texts.subList(visualModeStart, y2+1).map {
                    it.sub(/^    /, "");
                } 
                
                texts.deleteWithRange(visualModeStart, y2+1).insert(visualModeStart, lines); 
                
                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
            }
            case (':'.to_int) {
                enterCommandMode();
            }
        }
    }

    def view() {
        if(mode == VISUALMODE) {
            clearWithoutBlink(); 
            
            dirView(); 

            for(y:=0; y<visibleTexts.length(); y++) {
                line := visibleTexts.items(y);

                if(line == null) {
                    break;
                }

                y2 := viewYToRealY(y);
                cursor_line := viewYToRealY(cursorY);

                if((y2 >= visualModeStart && y2 <= cursor_line) || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attron(A_REVERSE);
                }


                ### cursor line ####
                mvprintw(y, 0 + dirPaneLength, line);

                if((y2 >= visualModeStart && y2 <= cursor_line) || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attroff(A_REVERSE);
                }
           }

           attron(A_REVERSE);
           try {
               mvprintw(MaxY-1, 0, "%s %d %d undo(%d:%d) size(%d,%d) cursor(%d,%d) scroll(%d,%d)", array { (self.fileName?.nothing():""), scrollTopY+cursorY, scrollTopX+cursorX, undoIndex, undoTexts.length(), MaxX, MaxY, cursorX, cursorY, scrollTopX, scrollTopY });
           }
           catch (e:Exception) {
           }
           attroff(A_REVERSE);
        }
        else {
            inherit();
        }
    }

    def runKeyEvents(key:int) {
        if(mode == VISUALMODE) {
            visualMode(key);
        }
        else {
            inherit(key);
        }
    }
}