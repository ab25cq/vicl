include "ViClone10MessageBox.clcl"

class ViClone
{
    visualModeStart:int;
    clipBoard:SortableList<String>;
     
    def initialize() {
        inherit();

        visualModeStart = 0;

        clipBoard = SortableList<String>();
    }

    def enterVisualMode() {
        mode = VISUALMODE;

        visualModeStart = scrollTopY+cursorY;
    }

    def clearClipBoard() {
        clipBoard.clear();
    }
    def addClipBoard(line:String) {
        clipBoard.add(line);
    }

    def pasteBeforeCursor() {
        addUndoText();

        val line = scrollTopY + cursorY;
        texts.insert(line, clipBoard.clone());

        fixCursorAndScrollTop(scrollTopY);
    }
    def pasteAfterCursor() {
        addUndoText();

        val line = scrollTopY + cursorY;
        texts.insert(line+1, clipBoard.clone());

        cursorY += clipBoard.length();

        fixCursorAndScrollTop(scrollTopY);
    }

    def defaultKeyEvents() {
        inherit();

        ### Insert Mode ###
        keyEvents['V'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            enterVisualMode();
        }
        keyEvents['p'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            pasteAfterCursor();
        }
        keyEvents['P'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            pasteBeforeCursor();
        }
    }

    def visualMode(key:int) {
        when(key) {
            case (('['-'A').to_int+1) {
                mode = EDITMODE;
                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('j'.to_int, KEY_DOWN) {
                cursorY++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('k'.to_int, KEY_UP) {
                cursorY--;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('l'.to_int, KEY_RIGHT) {
                cursorX++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('h'.to_int, KEY_LEFT) {
                cursorX--;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('y'.to_int) {
                val line = scrollTopY + cursorY;

                if(visualModeStart < line) {
                    clipBoard = texts.subList(visualModeStart, line+1);
                }
                else {
                    clipBoard = texts.subList(line, visualModeStart+1);
                }

                mode = EDITMODE;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('d'.to_int) {
                addUndoText();

                val line = scrollTopY + cursorY;

                if(visualModeStart < line) {
                    clipBoard = texts.subList(visualModeStart, line+1);
                    texts.deleteWithRange(visualModeStart, line+1);
                    cursorY -= line - visualModeStart;
                }
                else {
                    clipBoard = texts.subList(line, visualModeStart+1);
                    texts.deleteWithRange(line, visualModeStart+1);
                }

                mode = EDITMODE;
                fixCursorAndScrollTop(scrollTopY);
            }
            case (('D'-'A').to_int+1) {
                val maxy = getmaxy();
                cursorY += maxy / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            case (('U'-'A').to_int+1) {
                val maxy = getmaxy();
                cursorY -= maxy / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            case ('>'.to_int) {
                addUndoText();

                texts.subList(visualModeStart, cursorY+scrollTopY+1).each {
                    it.insert(0, "    ");
                } 
                
                fixCursorAndScrollTop(scrollTopY);
            }
            case ('<'.to_int) {
                addUndoText();

                y := visualModeStart; 
                
                lines := texts.subList(visualModeStart, cursorY+scrollTopY+1).map {
                    it.sub(/^    /, "");
                } 
                
                texts.deleteWithRange(visualModeStart, cursorY+scrollTopY+1).insert(visualModeStart, lines); 
                
                fixCursorAndScrollTop(scrollTopY);
            }
        }
    }

    def view() {
        if(mode == VISUALMODE) {
            clearWithoutBlink();

            val maxx = getmaxx();
            val maxy = getmaxy();

            var y = 0;

            var cursor_line = scrollTopY+cursorY;

            (visibleTexts?.nothing():texts.subList(scrollTopY, scrollTopY + maxy-1)).each {
                (line, over_maxx) := getLine(y+scrollTopY);

                val y2 = y + scrollTopY;

                if((y2 >= visualModeStart && y2 <= cursor_line)
                    || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attron(A_REVERSE);
                }

                ### cursor line ####
                if(cursorY == y) {
                    if(line.length() == 0) {
                        attron(A_REVERSE);
                        mvprintw(y,0, " ");
                        attroff(A_REVERSE);
                    }
                    else {
                        mvprintw(y, 0, line.subString(scrollTopX, scrollTopX+cursorX));

                        val c = line.chars(scrollTopX+cursorX);

                        attron(A_BOLD);
                        mvprintw(y, cursorX, c.toString());
                        attroff(A_BOLD);

                        if(line.length()-scrollTopX > maxx-1) {
                            mvprintw(y, cursorX+1, line.subString(scrollTopX+cursorX+1, scrollTopX+(maxx-1)));
                        }
                        else {
                            mvprintw(y, cursorX+1, line.subString(scrollTopX+cursorX+1, -1));
                        }
                    }
                }
                ### visible line ###
                else {
                    mvprintw(y, 0, line.subString(0, maxx-1));
                }

                if((y2 >= visualModeStart && y2 <= cursor_line)
                    || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attroff(A_REVERSE);
                }

                y++;
           }

            if(texts.length() == 0) {
                attron(A_REVERSE);
                if(fileName == null) {
                    mvprintw(maxy-1, 0, "VISUAL  %d %d", array { scrollTopY+cursorY, scrollTopX+cursorX });
                }
                else {
                    mvprintw(maxy-1, 0, "VISUAL %s %d %d", array { fileName, scrollTopY+cursorY, scrollTopX+cursorX });
                }
                attroff(A_REVERSE);
            }
            else {
                attron(A_REVERSE);
                if(fileName == null) {
                    mvprintw(maxy-1, 0, "VISUAL  %d(%d%%) %d", array { scrollTopY+cursorY, scrollTopY+cursorY/texts.length(), scrollTopX+cursorX });
                }
                else {
                    mvprintw(maxy-1, 0, "VISUAL %s %d(%d%%) %d", array { fileName, scrollTopY+cursorY, scrollTopY+cursorY/texts.length(), scrollTopX+cursorX });
                }
                attroff(A_REVERSE);
            }
        }
        else {
            inherit();
        }
    }

    def runKeyEvents(key:int) {
        if(mode == VISUALMODE) {
            visualMode(key);
        }
        else {
            inherit(key);
        }
    }
}
