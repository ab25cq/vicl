include "ViClone10MessageBox.clcl"

class ViClone
{
    visualModeStart:int;
    clipBoard:SortableList<String>;
     
    def initialize() {
        inherit();

        visualModeStart = 0;

        clipBoard = SortableList<String>();
    }

    def enterVisualMode() {
        mode = VISUALMODE;

        visualModeStart = scrollTopY+cursorY;
    }

    def clearClipBoard() {
        clipBoard.clear();
    }
    def addClipBoard(line:String) {
        clipBoard.add(line);
    }

    def pasteBeforeCursor() {
        addUndoText();

        val line = scrollTopY + cursorY;
        texts.insert(line, clipBoard.clone());

        makeVisibleTexts();
        fixCursorAndScrollTop(scrollTopY);
    }
    def pasteAfterCursor() {
        addUndoText();

        val line = scrollTopY + cursorY;
        texts.insert(line+1, clipBoard.clone());

        cursorY += clipBoard.length();

        makeVisibleTexts();
        fixCursorAndScrollTop(scrollTopY);
    }

    def defaultKeyEvents() {
        inherit();

        ### Insert Mode ###
        keyEvents['V'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            enterVisualMode();
        }
        keyEvents['p'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            pasteAfterCursor();
        }
        keyEvents['P'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            pasteBeforeCursor();
        }
    }

    def visualMode(key:int) {
        when(key) {
            case (('['-'A').to_int+1) {
                mode = EDITMODE;
                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('j'.to_int, KEY_DOWN) {
                cursorY++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('k'.to_int, KEY_UP) {
                cursorY--;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('l'.to_int, KEY_RIGHT) {
                cursorX++;

                fixCursorAndScrollTop(scrollTopY);
            }
            
            case ('h'.to_int, KEY_LEFT) {
                cursorX--;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('y'.to_int) {
                val line = scrollTopY + cursorY;

                if(visualModeStart < line) {
                    clipBoard = texts.subList(visualModeStart, line+1);
                }
                else {
                    clipBoard = texts.subList(line, visualModeStart+1);
                }

                mode = EDITMODE;

                fixCursorAndScrollTop(scrollTopY);
            }

            case ('d'.to_int) {
                addUndoText();

                val line = scrollTopY + cursorY;

                if(visualModeStart < line) {
                    clipBoard = texts.subList(visualModeStart, line+1);
                    texts.deleteWithRange(visualModeStart, line+1);
                    cursorY -= line - visualModeStart;
                }
                else {
                    clipBoard = texts.subList(line, visualModeStart+1);
                    texts.deleteWithRange(line, visualModeStart+1);
                }

                mode = EDITMODE;
                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
            }
            case (('D'-'A').to_int+1) {
                val maxy = getmaxy();
                cursorY += maxy / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            case (('U'-'A').to_int+1) {
                val maxy = getmaxy();
                cursorY -= maxy / 2;

                fixCursorAndScrollTop(scrollTopY);
            }
            case ('>'.to_int) {
                addUndoText();

                texts.subList(visualModeStart, cursorY+scrollTopY+1).each {
                    it.insert(0, "    ");
                } 
                
                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
            }
            case ('<'.to_int) {
                addUndoText();

                y := visualModeStart; 
                
                lines := texts.subList(visualModeStart, cursorY+scrollTopY+1).map {
                    it.sub(/^    /, "");
                } 
                
                texts.deleteWithRange(visualModeStart, cursorY+scrollTopY+1).insert(visualModeStart, lines); 
                
                makeVisibleTexts(); 
                fixCursorAndScrollTop(scrollTopY);
            }
        }
    }

    def view() {
        if(mode == VISUALMODE) {
            clearWithoutBlink(); 
            
            dirView(); 

            var y = 0;

            var cursor_line = scrollTopY+cursorY;

            visibleTexts.each {
                over_maxx := it.length() >= MaxX-1;

                val y2 = y + scrollTopY;

                if((y2 >= visualModeStart && y2 <= cursor_line)
                    || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attron(A_REVERSE);
                }

                ### cursor line ####
                if(cursorY == y) {
                    if(it.length() == 0) {
                        mvprintw(y,0+dirPaneLength, " ");
                    }
                    else {
                        mvprintw(y, 0+dirPaneLength, it.subString(scrollTopX, scrollTopX+cursorX));

                        val c = it.chars(scrollTopX+cursorX);

                        mvprintw(y, cursorX+dirPaneLength, c.toString());

                        if(it.length()-scrollTopX > MaxX-1) {
                            mvprintw(y, cursorX+1+dirPaneLength, it.subString(scrollTopX+cursorX+1, scrollTopX+(MaxX-1)));
                        }
                        else {
                            mvprintw(y, cursorX+1+dirPaneLength, it.subString(scrollTopX+cursorX+1, -1));
                        }
                    }
                }
                ### visible line ###
                else {
                    mvprintw(y, 0+dirPaneLength, it.subString(0, MaxX-1));
                }

                if((y2 >= visualModeStart && y2 <= cursor_line)
                    || (y2 >= cursor_line && y2 <= visualModeStart))
                {
                    attroff(A_REVERSE);
                }

                y++;
           }

           attron(A_REVERSE);
           try {
               mvprintw(MaxY-1, 0, "%s %d %d undo(%d:%d) size(%d,%d) cursor(%d,%d) scroll(%d,%d)", array { (self.fileName?.nothing():""), scrollTopY+cursorY, scrollTopX+cursorX, undoIndex, undoTexts.length(), MaxX, MaxY, cursorX, cursorY, scrollTopX, scrollTopY });
           }
           catch (e:Exception) {
           }
           attroff(A_REVERSE);
        }
        else {
            inherit();
        }
    }

    def runKeyEvents(key:int) {
        if(mode == VISUALMODE) {
            visualMode(key);
        }
        else {
            inherit(key);
        }
    }
}