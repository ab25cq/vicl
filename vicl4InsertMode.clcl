include "vicl3.3View.clcl"

class ViClone
{
    var tabSize:int;
     
    def initialize() {
        inherit();
        
        tabSize = 4; 
    }

    def fixCursorAndScrollTop(scrolltop_y_before:int) {
        if(mode == INSERTMODE) {
            (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);
            line := texts.items(y);

            if(cursorX == MaxX-1 && x == line.length()) {
            }
            elif(cursorX == MaxX && x == line.length()) {
                cursorX = 1;
                cursorY++;
            }
            else {
                if(cursorX >= MaxX-1) {
                    cursorX = 0;
                    cursorY++;
                }
            }

            inherit(scrolltop_y_before);
        }
        else {
            inherit(scrolltop_y_before);
        }
    }
    
    def viewYToRealY(y:int):int {
        (y2, x2, line_size) := viewPosToRealPos(y, 0);
        return y2;
    }

    def realYToViewY(y:int):int {
        (y2, x2) := realPosToViewPos(y, 0);
        return y2;
    }

    def viewPosToRealPos(y:int, x:int): Tuple3<Integer, Integer, Integer>
    {
        if(y >= 0 && y < visibleTextsPos.length()) {
            (y2, x2, line_size) := visibleTextsPos.items(y);
            return (y2, x + x2, line_size);
        }
        else {
            throw Exception("viewPosToRealPos");
        }
    }

    def getRealPosY():int {
        (y, x, line_size) := visibleTextsPos.items(cursorY);
        return y;
    }

    def getRealPosX():int {
        (y, x, line_size) := visibleTextsPos.items(cursorY);
        return x + cursorX;
    }

    def getRealPosYOfMaxY():int {
        (y, x, line_size) := visibleTextsPos.items(MaxY-2);
        return y;
    }

    def realPosToViewPos(y:int, x:int): Tuple2<Integer, Integer>
    {
        for(i:=0; i<visibleTextsPos.length(); i++)
        {
            (y2, x2, line_num) := visibleTextsPos.items(i);

            if(y2 == y) {
                if(x >= x2 && x < x2 + MaxX-1)
                {
                    return (i, x-x2);
                }
            }
        }

        return (-1,-1)
    }
    
    def moveCursor(y:int, x:int):int {
        (y2,x2)  := realPosToViewPos(y, x);
        
        if(y2 >= 0 && y2 < visibleTexts.length())
        {
            (cursorY, cursorX) = realPosToViewPos(y, x);
        }
        else {
            scroll_size := (MaxY-1)/2;
            scrollTopY = y - scroll_size;

            fixCursorAndScrollTop(scrollTopY);
            makeVisibleTexts();

            (cursorY, cursorX) = realPosToViewPos(y, x);

            if(cursorY == -1 && cursorX == -1) {
                scrollTopY = y;

                fixCursorAndScrollTop(scrollTopY);
                makeVisibleTexts();

                (cursorY, cursorX) = realPosToViewPos(y, x);
                fixCursorAndScrollTop(scrollTopY);
                makeVisibleTexts();
            }
            else {
                fixCursorAndScrollTop(scrollTopY);
                makeVisibleTexts();
            }
        }
    }

    def enterNewLine(no_tails_getting:bool) {
        (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);

        line := texts.items(y);

        spaces_num := line.scan(/^\s+/)?.items(0).length():0;

        tails := "";
        if(!no_tails_getting) {
            tails = line.subString(x..-1);
            line.delete(x..-1);
        }

        cursorX = spaces_num;
        cursorY++;

        if(cursorY >= MaxY-1) {
            (tmp, tmp2, top_line_size) := visibleTextsPos.items(0);

            if(top_line_size >= MaxY-1) {
                scrollTopY++;
                cursorY = 0;
                cursorX = 0;
            }
            else {
                scroll_size := cursorY - MaxY +2;

                scrollTopY += scroll_size;
                cursorY -= scroll_size + top_line_size -1;
            }
        }
        
        spaces := " ".multiply(spaces_num);
        spaces.append(tails);
        texts.insert(y+1, spaces);

        makeVisibleTexts();
        fixCursorAndScrollTop(scrollTopY);

        cursorX = spaces_num;
    }

    def enterInsertMode() {
        mode = INSERTMODE;
    }

    def defaultKeyEvents() {
        inherit();

        ### Insert Mode ###
        keyEvents['i'.to_int] = lambda(self:ViClone, key:int, key2:int) {
           addUndoText();

           enterInsertMode();
        }

        keyEvents['a'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            addUndoText();

            cursorX++;

            clear();
            view();

            enterInsertMode();
        }
        keyEvents['A'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            addUndoText();

            line := texts.items(getRealPosY());

            if(line != null && line.length() != 0) {
                (y, x) := realPosToViewPos(getRealPosY(), line.length()-1);

                if(y == 0 && x == 0 && getRealPosY() != 0) {
                    scrollTopY = getRealPosY();
                    cursorY = 0;
                    makeVisibleTexts();

                    (cursorY, cursorX) = realPosToViewPos(getRealPosY(), line.length()-1);
                }
                else {
                    cursorY = y;
                    cursorX = x;
                }

                makeVisibleTexts();
                fixCursorAndScrollTop(scrollTopY);
                cursorX++;

                clear();
                view();
            }

            enterInsertMode();
        }
        keyEvents['o'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            addUndoText();

            enterNewLine(true);

            enterInsertMode();
        }
        keyEvents['c'.to_int] = lambda(self:ViClone, key:int, key2:int) {
            addUndoText();
             
            when(key2) {
                case ('e'.to_int, 'w'.to_int) {
                    (y, x) := forwardWord(0); 
                    
                    real_pos_y := getRealPosY();
                    real_pos_x := getRealPosX();
                 
                    line := texts.items(real_pos_y);
                    
                    if(y > real_pos_y) {
                        line.delete(real_pos_x, -1);
    
                        makeVisibleTexts();                     
                        fixCursorAndScrollTop(scrollTopY);
            
                        cursorX++;
                    } 
                    else { 
                        line.delete(real_pos_x, x); 
    
                        makeVisibleTexts();                     
                        fixCursorAndScrollTop(scrollTopY);
                    } 
                     
                    enterInsertMode();
                }
                case ('d'.to_int) {
                }
            }
        }
        keyEvents[('L'-'A').to_int+1] = lambda(self:ViClone, key:int, key2:int) {  # Control-L
            makeVisibleTexts()
            clear();
            view();
        }
    }

    def insertMode(key:int) {
        when(key) {
            case (('['-'A').to_int+1, ('C'-'A').to_int+1) {
                mode = EDITMODE;
                #fixCursorAndScrollTop(scrollTopY);
            }

            ### Backspace ###
            case (('H'-'A').to_int+1, KEY_BACKSPACE) {
                (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);

                line := texts.items(y);
                
                if(line != null && cursorX >= 0) {
                    line.delete(x -1);
                    cursorX--;
                } 
                
                makeVisibleTexts();
            }

            case (('D'-'A').to_int+1) {
                (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);

                line := texts.items(y);
                
                if(line != null) {
                    4.times {
                        if(cursorX >= 0) {
                            line.delete(x -1);
                            cursorX--;
                        }
                    }
                } 
                
                makeVisibleTexts();
            } 

            ### delete Back word ###
            case (('W'-'A').to_int+1) {
                line := texts.items(getRealPosY());
                
                real_pos_y := getRealPosY();
                real_pos_x := getRealPosX();

                (y, x) := backwardWord(-1);
                
                if(line != null) {
                    if(y == real_pos_y) {
                        (real_pos_x - x).times { 
                            line.delete(getRealPosX()-1);
                        }
                        makeVisibleTexts();
                        moveCursor(y, x);
                    } 
                    elif(y < real_pos_y) {
                        for(i:=real_pos_y; i>y; i--) {
                            line = texts.items(i);
                            line.setValue("");
                        }
                        
                        line = texts.items(i);
                        
                        line.delete(x, -1);
                        makeVisibleTexts();
                        moveCursor(y, x);
                    }
                } 
            }

            case ('\n'.to_int) {
                enterNewLine(false);
                
                makeVisibleTexts();
            }
            
            case (('X'-'A').to_int+1) {
                clover2Completion();
            }

            case (('I'-'A').to_int+1) {
                (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);

                line := texts.items(y);
                
                if(line != null) {
                    if(line.subString(0, x).match(/^\s*$/)) {
                        4.times { 
                            line.insert(x, " ");
                            cursorX++;
                        } 
                    }
                    else {
                        completion();
                    }
                }
                
                makeVisibleTexts();
            }
            else {
                (y, x, line_size) := viewPosToRealPos(cursorY, cursorX);
                line := texts.items(y);
                
                if(line != null) {
                    c := key.to_char;
                    if(c.isalnum() || c == ' ' || c.isgraph()) {
                        line.insert(x, c.toString());

                        makeVisibleTexts();
                        cursorX++;
                        
                        fixCursorAndScrollTop(scrollTopY);
                    }
                }
            }
        }
    }

    def runKeyEvents(key:int) {
        if(mode == INSERTMODE) {
            modifiedText = true;
            insertMode(key);
        }
        else {
            inherit(key);
        }
    }

    def clearStatusLine() {
        maxy := getmaxy();
        maxx := getmaxx();

        line := " ".multiply(maxx-1);

        mvprintw(maxy-1, 0, line);
    }

    def view() {
        inherit(); 

        if(mode == INSERTMODE) {
            maxy := getmaxy();

            clearStatusLine();

            if(texts.length() == 0) {
                attron(A_REVERSE);
                if(fileName == null) {
                    mvprintw(maxy-1, 0, "INSERT  %d %d", array { scrollTopY+cursorY, scrollTopX+cursorX });
                }
                else {
                    mvprintw(maxy-1, 0, "INSERT %s %d %d", array { fileName, scrollTopY+cursorY, scrollTopX+cursorX });
                }
                attroff(A_REVERSE);
            }
            else {
                attron(A_REVERSE);
                if(fileName == null) {
                    mvprintw(maxy-1, 0, "INSERT  %d(%d%%) %d", array { scrollTopY+cursorY, scrollTopY+cursorY/texts.length(), scrollTopX+cursorX });
                }
                else {
                    mvprintw(maxy-1, 0, "INSERT %s %d(%d%%) %d", array { fileName, scrollTopY+cursorY, scrollTopY+cursorY/texts.length(), scrollTopX+cursorX });
                }
                attroff(A_REVERSE);
            }
        }
    }
}
